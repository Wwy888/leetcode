Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list.

 

Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.


Example 2:

Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.


Example 3:

Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.


 

Follow-up:
Can you solve it without using extra space?


/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        HashSet<ListNode>set=new HashSet<>();
        if(head==null){
            return head;
        }
        while(head!=null){
            if(set.contains(head)){
                return head;
            }
            else{
                set.add(head);
                head=head.next;
            }
        }
        return null;
    }
}

最简单的hashset 解法

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
      if(head==null){
          return head;
      }
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow){
                while(head!=fast){
                    head=head.next;
                    fast=fast.next;
                }
                return head;
            }
        }
        return null;
    }
}

双指针解法，快指针和慢指针。如果有环，一定会相遇。问题在于判断头节点，这里就用到公式推理。
假设慢节点走的距离是t,快节点走的距离则是2t.
assume the distance from head to the starting point of the circle is c. the distance from starting point of the circle to
the point where they meet is a. distance rom meet point to the staring point of the circle is b. 
we can get the formula t=c+a; 2t=c+a+(a+b)*n;
simplyfies it. c=(n-1)*(a+b)+b;
which means that if a point starts from head and the point runs c. in the meantime another point stars from the meeting point and the two point gonna meet at
the starting point of the circle. b is the distance from the meeting point to starring point of the circle.






