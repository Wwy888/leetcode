A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
Note:

Your solution should be in logarithmic complexity.


class Solution {
    public int findPeakElement(int[] nums) {
        int left=0;
        int right=nums.length-1;
        while(left<right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]<nums[mid+1]){
                left=mid+1;
            }
            else if(nums[mid]>nums[mid+1]){
                right=mid;
            }
            else 
                return mid;
        }
        return left;
    }
}

方法：这个题返回局部峰值，不需要遍历整个数组，而且最大元素一定存在，没有重复的元素，所以循环退出条件为left=right。
分为三种情况：
比较mid 和 mid+1 的大小， 如果mid大于mid+1，说明mid可能是局部峰值，令right=mid,
                        如果mid小于mid+1，说明mid+1可能是局部峰值，left=mid+1.
                        如果都不符合，因为没有重复元素，所以mid本身是局部峰值，直接返回mid
                        
退出循环的条件：left=right，返回left。


class Solution {
    public int findPeakElement(int[] nums) {
        int left=0;
        int right=nums.length-1;
        while(left+1<right){
            int mid=left+(right-left)/2;
            if(nums[mid]<=nums[mid+1]){
                left=mid;
            }
            else right=mid;
        }
        if(nums[left]<nums[right]){
            return right;
        }else return left;
    }
}
最后需要post processing，判断left和right哪个更大。
