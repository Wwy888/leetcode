Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?



/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution 
{
    public ListNode reverseList(ListNode head) 
    {
        ListNode nxt;
        ListNode pre=null;
        ListNode cur=head;
        while(cur!=null)
        {
            nxt=cur.next;    //nxt指针保存cur.next
            cur.next=pre;    //实现翻转, cur指向pre,cur的下一个点为pre;
            pre=cur;         //  挪动指针pre
            cur=nxt;         // 挪动指针 cur;
        }
        return pre;   
    }        
}

方法：
设置三个节点pre、cur、next

（1）每次查看cur节点是否为NULL，如果是，则结束循环，获得结果
（2）如果cur节点不是为NULL，则先设置临时变量next为cur的下一个节点
（3）让cur的下一个节点变成指向pre，而后pre移动cur，cur移动到next
（4）重复（1）（2）（3）

一个一个向右移

recursion 写法：
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode newhead=reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return newhead;
    }
}
假设右6个节点，从1开始连接到6，6的后面是null。
首先判断base case，到6节点，它的后面是null，这时候return。
if（head==null｜｜head.next==null）return head；

我开始recursion，newhead=reverseList（head.next）//wall 
Recursion 相当于挖坑的过程，挖了一个一个坑，返回的过程相当于填坑，把一个一个坑填上。此时我开始返回6节点，返回到5那一层，此时head节点是5，
head.next.next=head // 相当于5节点的下个节点是6，6节点的下一个节点指向5，相当于把linklist 反向。
head.next=null；在后面添加null。
在每一层返回上来的头节点都是6，当前层的头节点是本身。最后newhead就是返回上来的6节点。
return newhead


