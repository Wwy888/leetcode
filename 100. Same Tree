Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false

/**  recursive
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) {
    // p and q are both null
    if (p == null && q == null) return true;
    // one of p and q is null
    if (q == null || p == null) return false;
    if (p.val != q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
            
  }
}


方法：
Return 返回之后下面的代码就不会执行了，返回到调用的地方。
[1,null,2][1,null,3]之所以会返回false， 是因为左子树返回一个true，返回到调用到左子树的地方，isSameTree（p.left,q.left）  
因为最后的return 是issameTree()&& issameTree() 所以，要等右子树返回的return。 右子树返回false。 最后是false


/** . iterative
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) 
  {
     Queue<TreeNode> queue=new LinkedList<>();
     queue.add(p);
      queue.add(q);
      while(!queue.isEmpty()){
          TreeNode node1=queue.poll();
          TreeNode node2=queue.poll();
          
          if(node1==null&&node2==null)
          {
              continue;
          }
          if(node1==null||node2==null||node1.val!=node2.val){
              return false;
          }
          queue.add(node1.left);
          queue.add(node2.left);
          queue.add(node1.right);
          queue.add(node2.right);
      }
      return true;
  }
}

方法：
Stack 和Queue 的元素都可以为null
主要是判断条件，然后遍历整个tree

