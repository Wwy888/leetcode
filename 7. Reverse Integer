Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21
Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

class Solution {
    public int reverse(int x) {
        int rev=0;
        while(x!=0){
            
            int pop=x%10;
            x/=10;
            if((rev>Integer.MAX_VALUE/10)||(rev==Integer.MAX_VALUE&&pop>7))
            {
                return 0;
            
            }
            if((rev<Integer.MIN_VALUE/10)||(rev==Integer.MIN_VALUE&&pop<-7))
            {
                return 0;
            }
            rev=rev*10+pop;
            
        }
        return rev;
       
    }
}

方法：
https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/
实现翻转：
每次取整数的最后一位，把它挪到最前面。
取个位，整数取余得到pop。
挪到最前面：rev*10+pop

考虑边界溢出问题，如果rev比Maxvalue/10 大，一定溢出，因为整数的除法是取整，即使是多了1， 乘10 之后 相当于多了10 ，
如果等于Max value/10，而POP比7大，就会溢出，因为Max value 是2147483647，取余为7，
