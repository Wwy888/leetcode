Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false



class Solution 
{
    public boolean containsNearbyDuplicate(int[] nums, int k) 
    {
        HashSet<Integer> set=new HashSet<Integer>();
        
        for(int i=0;i<nums.length;i++)
        {
            if(i>k)
            {
                set.remove(nums[i-k-1]);
            }
            if(!set.add(nums[i]))
            {
                return true;
            }
        }
        return false;
        }
        
    }
    
    方法：
    利用hash set的元素唯一性，先判断当前元素在数组中的顺序是否大于K，如果大于k,减去k步之前的元素（题目要求k步以内）。
    再判断是否包括相同的元素，如果包括返回true，没有则添加
    
    for循环之所以长度为nums.length而不是nums.legnth-1是因为 i是从0开始的，假设k为3，如果数组的最后一个元素的序号为3，就会直接跳出循环，
    没有判断最后一个元素是否相同，所以for循环的条件是nums.length-1
    
    
