Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
Example 2:

Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
Note:

The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null||head.next==null)
        {
            return head;
        }
        ListNode odd,even,evenhead;
        odd=head;
        even=odd.next;
        evenhead=even;
        while(even!=null&&even.next!=null)
        {
            odd.next=even.next;
            odd=odd.next;
            even.next=odd.next;
            even=even.next;
        }
        odd.next=evenhead;
        return head;
    }
}

方法：
https://www.jianshu.com/p/2b94c5560087

in-place algorithm：

In computer science, an in-place algorithm is an algorithm which transforms input using no auxiliary data structure.
However a small amount of extra storage space is allowed for auxiliary variables. 
The input is usually overwritten by the output as the algorithm executes. 
In-place algorithm updates input sequence only through replacement or swapping of elements. 
An algorithm which is not in-place is sometimes called not-in-place or out-of-place.
一句话总结就是: 原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。

这个题是分成两个linked list去做，一个是odd, 一个是even。
三个指针， odd,even, evenhead;
fist of all, odd =head, even=head.next; evenhead= even;
odd.next= even.next // 把第一个odd指向第二个odd
odd = odd.next // odd 移动到下一个odd处 
even.next=even；//第一个even指向第二个even
even= even.next； // even 移动到下个even 处
odd.next=evenhead； // 最后一个odd到下个点是even head， 把两个链连接起来

