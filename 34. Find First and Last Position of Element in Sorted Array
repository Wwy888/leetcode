Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]


class Solution {
    public int[] searchRange(int[] nums, int target) 
    {
      int [] res={-1,-1};
        int left=0;
        int right=nums.length-1;
        int st_point=-1;
        int end_point=-1;
        if(nums.length==0){
            return res;
        }
        //looking for the start point;
        while(left+1<right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                right=mid;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid;
            }  
        }
         if(nums[left]==target){
                st_point=left;
            }
        else if(nums[right]==target){
            st_point=right;
        }
        if(st_point==-1){
            return res;
        }
        
        //looking for the end point 
        left=0;right=nums.length-1;
        while(left+1<right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                left=mid;
            }
            else if(nums[mid]<target){
                left=mid+1;

            }
            else {
                right=mid;
            }
        }
        if(nums[right]==target){
            end_point=right;
        }
        else if(nums[left]==target){
            end_point=left;
        }
         
        res[0]=st_point;
        res[1]=end_point;
        return res;
    }
}

方法：这个题是要判断边界范围。
首先找左边界，循环条件是left+1<right 就是要避免当数组中只有两个元素的时候，mid=left+（right-left）/2 ，mid 一直为0 ，陷入死循环的情况。
循环中有三种情况，如果mid ==target，要让left=mid, 让整个范围向左移动，如果
 mid <target，left=middle +1，如果middle大于target，right=middle；
 
确定左端点，如果nums[left]==target, range的左端点为left，如果nums[right]为target，则左端点为right。
同样找右端点重新开始循环，也是三种情况，如果mid ==target，要让right=mid, 让整个范围向右移动，如果
 mid <target，left=middle +1，如果middle大于target，right=middle；
确定右端点，如果nums[right]==target, range的右端点为right，如果nums[left]为target，则右端点为left。

            
